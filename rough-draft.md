	
In keeping with the Von Neumann model of computer architecture, computer systems have traditionally separated computation, performed by a dedicated processor, from data storage, typically accomplished by a hard disk drive (HDD), or more recently, a solid state drive (SSD). Over the past few decades, processor performance has improved dramatically. Storage access latency has not enjoyed similar improvement.

The result of this mismatch is that storage access has become the most significant limiting factor for computing performance. This is particularly true for data intensive applications, which have become ever more prevalent with the advent of big data.

In the last few years, SSDs have entered the commercial mainstream of storage devices. SSDs offer significant performance improvement in access latency over HDDs. However, as flash-based devices, SSDs also differ from HDDs in a number of use-relevant ways. Unlike HDDs, SSDs have different granularity for reads and writes, cannot write to dirty pages before clearing them, and have lifetime limits on number of writes per block before a given block becomes unusable. These differences necessitate different access patterns from those appropriate for HDDs. To work seamlessly with the HDD-optimized storage interfaces common among host machines, SSDs must therefore perform additional logic known as the flash translation layer (FTL) to process traditional read-write requests from the host. To accomplish this, SSDs come equipped with their own internal processors and DRAM.

The additional computational resources in peripheral devices such as SSDs create an opportunity to bypass the bottleneck of data transfer by moving away from the classical von Neumann separation of computation and data storage. By moving some of the computational tasks in a program to near-data processors such as those found in SSDs, a more distributed model of computing can reduce the traffic between the central processing unit and peripheral devices. Several strategies for offloading computation to peripheral device processors exist.

[go through different papers, explaining the approach they offer, and point out limitations and shortcomings]

[question – should I present all approaches from other papers without criticism, and then have a separate section for criticizing each one in turn? Or should I present and then criticize one paper at a time. i.e. present A, present B, present C, criticize A, criticize B, criticize C,… or… present A, criticize A, present B, criticize B, present C, criticize C]

The work that most directly inspired the current project is described in a paper titled, “Morpheus: Creating Application Objects Efficiently for Heterogeneous Computing”. Dr. Tseng et al present a model of computation called Morpheus, in which the host machine compiles and transmits code to the SSD, which then processes data and transmits the results back to a corresponding program running on the host machine, generated by the same compiler. By targeting the data-intensive task of deserialization – specifically, of ASCII stored values into C-compatible integer arrays – their Morpheus-SSD implementation reduced context switching by an average of 98% in the host machine, energy consumption by upwards of 42%, and execution time by varying but significant margins on a wide range of applications.

The primary drawback of the Morpheus project is its reliance on the programmer to manually write code intended for execution on the SSD. Code to be executed on the SSD must be written in C, and is exceptionally challenging to debug. These factors make Morpheus less flexible and programmer-friendly than is practical for adoption by mainstream application developers.

The project presented here is intended to overcome the limitations of Morpheus while preserving the performance benefits this model of computation can offer. To achieve this, we move the burden of code generation for the SSD from the programmer to the compiler platform itself. This project targets Python, for its widespread popularity, by extending a just-in-time compiler project for the language with Morpheus-like capabilities to share data and code across PCIe. 





